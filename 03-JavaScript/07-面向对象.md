> 介绍如何在 JavaScript 中面向对象编程。

## 方法（method）

我们已经知道，JavaScript 是有对象（object）字面量的，所以我们可以直接创建对象。当把函数赋给对象的属性时，该函数便是对象的方法。例如：

```js
harry = {
  name: 'Harry Smith',
  salary: 90000,
  raiseSalary: function (percent) {
    this.salary *= 1 + percent / 100;     // this 指向对象本身
  }
};

// 访问方法
harry.raiseSalary(10);
```

## 对象构造器（object constructor）

有时我们需要生成多个同类对象，这时再用字面量一个个写就不合适了。我们可以选择使用对象构造器，像工厂一样生产出很多对象。例如：

```js
// 对象构造器，其实就是一个没有 return 语句的函数
// 构造器名称通常是首字母大写，如 Dog
// 参数和对象属性对应
// 参数名和属性名不必相同，但惯例上是相同的
function Dog(name, breed, weight) {
  this.name = name;
  this.breed = breed;
  this.weight = weight;
}

// 使用构造器创建对象
// 使用关键字 new
let fido = new Dog("Fido", "Mixed", 38);
let fluffy = new Dog("Fluffy", "Poodle", 30);
let spot = new Dog("Spot", "Chihuahua", 10);
```
对象构造器的工作流程如下：

![对象构造器工作流程](../_images/对象构造器工作流程.svg ':size=600')

对象构造器里同样可以添加方法：

```js
// 【方法】就是把匿名函数赋给属性
function Dog(name, breed, weight) {
  this.name = name;
  this.breed = breed;
  this.weight = weight;

  this.bark = function () {
    let msg = "";
    if (this.weight > 25) {
      msg = `${this.name} says Woof!`;
    } else {
      msg = `${this.name} says Yip!`;
    }
    alert(msg);
  };
}

// 使用构造器创建实例
// 再调用 bark 方法
let fido = new Dog("Fido", "Mixed", 38);
fido.bark();      // Fido says Woof!
```

当对象构造器参数比较多时，我们要一个个按照顺序把实参传入，这是比较容易出错的。我们可以把参数打包成对象：

```js
// 创建实例时，params 被赋值为传入的对象
function Dog(params) {
  // 直接用到参数的部分需要修改
  this.name = params.name;
  this.breed = params.breed;
  this.weight = params.weight;

  // 这个方法里用的是 this，所以不用修改
  this.bark = function () {
    let msg = "";
    if (this.weight > 25) {
      msg = `${this.name} says Woof!`;
    } else {
      msg = `${this.name} says Yip!`;
    }
    alert(msg);
  };
}

// 使用对象作为参数，好处是可以乱序
let fidoParams = {
  name: "Fido",
  breed: "Mixed",
  weight: 38
};

// 使用构造器创建实例
// 再调用 bark 方法
let fido = new Dog(fidoParams);
fido.bark();      // Fido says Woof!
```

如果需要检测某个实例（instance）是否是某个对象构造器 `new` 出来的，需要使用 `instanceof` 操作符：

```js
// instanceof 操作符返回 true 或 false
if (fido instanceof Dog) {
  console.log("fido is a Dog.");
}
```

## 原型（prototype）

我们再考察一下上面的构造器例子：

```js
function Dog(name, breed, weight) {
  this.name = name;
  this.breed = breed;
  this.weight = weight;

  this.bark = function () {
    let msg = "";
    if (this.weight > 25) {
      msg = `${this.name} says Woof!`;
    } else {
      msg = `${this.name} says Yip!`;
    }
    alert(msg);
  };
}
```

我们会发现，在代码层面上，我们实现了方法的复用。但是，当运行时，每个实例都会创建自己的 `bark` 方法，从而都要占用一份内存。而实际上，所有 `bark` 方法的的代码是一样的。假如能让所有实例的 `bark` 方法都指向内存中的同一个方法实例，就可以避免无谓的内存消耗。JavaScript 使用所谓的原型继承（prototypal inheritance）来解决这个问题，被继承的对象称为**原型**（prototype）。当一个对象继承另一个对象时，它可以访问被继承对象的所有方法和属性。

```js
// 把各个实例具有独特属性值的属性放在构造器
function Dog(name, breed, weight) {
  this.name = name;
  this.breed = breed;
  this.weight = weight;
}

// 把各个实例共有的属性或方法添加到构造器的原型
// Dog.prototype 实质是一个对象
Dog.prototype.species = "Canine";
Dog.prototype.bark = function () {
  let msg = "";
  if (this.weight > 25) {
    msg = `${this.name} says Woof!`;
  } else {
    msg = `${this.name} says Yip!`;
  }
  alert(msg);
};

// 还是像之前一样，使用构造器创建实例
let fido = new Dog("Fido", "Mixed", 38);
console.log(fido.species);      // "Canine"
// 原型方法里的 this 会正确地指向当前实例
fido.bark();      // Fido says Woof!
```

通过下图，可更清晰地观察构造器与其原型的继承关系：

![构造器与其原型的继承关系](../_images/prototype.svg ':size=600')

当执行 `fido.bark();` 时，会先在 `fido` 实例里查寻是否有 `bark` 方法，如果没有，就向上，在原型里查找。因此，我们可以在实例里设置与原型属性重名的属性，来影蔽（shadowy）掉原型属性，而不影响其他实例对原型属性的引用。例如：

```js
// 创建一个新的 Dog 实例 spot
let spot = new Dog("Spot", "Chihuahua", 10);

// 给 spot 对象添加 bark 方法
// 这样就影蔽掉原型里的同名方法
spot.bark = function () {
  console.log(`${this.name} says WOOF WOOF!`);
}

// 因为 spot 实例里有 bark 方法，
// 所以不用向上到原型里查找该方法
spot.bark();
```

另外，原型是可以动态更改的。给原型添加属性或方法，所有实例都能引用。就算是先创建实例，再修改原型，也是可以的。

还有一种节省内存的技巧是，在原型里设置属性**默认值**，当某实例需要更改该默认值时，再给该实例**添加同名属性**。例如：

```js
// 默认不处于“坐”的状态
Dog.prototype.sitting = false;

// sit 方法
Dog.prototype.sit = function () {
  if (this.sitting) {
    console.log(`${this.name} is already sitting`);
  } else {
    // 注意，this 是指向实例的
    // 所以 this.sitting = true; 是给实例添加 sitting 属性
    // 而没有修改原型的属性
    this.sitting = true;
    console.log(`${this.name} is now sitting`);
  }
};

console.log(fido.sitting);      // false
fido.sit();     // Fido is now sitting
console.log(fido.sitting);      // true
console.log(spot.sitting);      // false
```

## 原型链（chain of prototypes）











> 更新时间：{docsify-updated}